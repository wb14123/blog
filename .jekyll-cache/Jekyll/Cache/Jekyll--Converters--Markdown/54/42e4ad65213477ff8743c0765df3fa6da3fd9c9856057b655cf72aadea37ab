I"Þ!<p>These days I start learning erlang, and building a poker robot system. While I am learning it, I found the most difficult part is not the function style programming, nor the OTP system. The most difficult part is how to build and run erlang. Surely you can write an erlang module and run the functions from the erlang shell when you do exercises, but it is a little disturbing. And you surely donâ€™t want to do that in the production environment. The erlang way and reltool is a little difficult for the newbies. Thanks to rebar, we can do it much easier now.</p>

<p><a href="https://github.com/basho/rebar">Rebar</a> is a very good tool to build and run erlang applications. It could automatic get dependencies, run it as a daemon, attach it and hot load code. Iâ€™m wonder why there is no book about erlang introduced it. Even the book <em>Learn You Some Erlang for Great Good</em>, which is published this year. The rebar official wiki is a little simple. I will record how am I using rebar to build erlang applications.</p>

<h2 id="basic">Basic</h2>

<p>A typical erlang directory structure is like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myapp:
 - src/
 - include/
 - priv/
 - ebin/
</code></pre></div></div>

<ul>
  <li>src: place for source code.</li>
  <li>include: place for included files, such as <code class="language-plaintext highlighter-rouge">.hrl</code> files.</li>
  <li>priv: not used for me now.</li>
  <li>ebin: place for erlang object files, such as <code class="language-plaintext highlighter-rouge">.beam</code> files, <code class="language-plaintext highlighter-rouge">.app</code> file also placed here.</li>
</ul>

<p>You usually need not to place any files in <code class="language-plaintext highlighter-rouge">ebin/</code> if you use rebar. All the object files, and <code class="language-plaintext highlighter-rouge">.app</code> files, could be compiled from sorce code. In a project, there may also have such two subdirectory: <code class="language-plaintext highlighter-rouge">deps</code> for dependencies and <code class="language-plaintext highlighter-rouge">test</code> for test files.</p>

<p>After download rebar, this command could create an OTP application:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rebar create-app app-id=myapp
</code></pre></div></div>

<p>It will create a directory with a <code class="language-plaintext highlighter-rouge">src/</code> subdirectory, and a file named <code class="language-plaintext highlighter-rouge">rebar.config</code>. As the name specified, <code class="language-plaintext highlighter-rouge">rebar.config</code> is the erlang config file.</p>

<p>Use this command could build this app:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rebar compile
</code></pre></div></div>

<h2 id="dependency">Dependency</h2>

<p>Lots of languages could manage dependencies easily now. For example, gem in ruby, npm in node.js, pip in python, maven in java and so on. Erlang is an old language, but with rebar, you could manage dependencies easily.</p>

<p>Run <code class="language-plaintext highlighter-rouge">rebar help get-deps</code> to see how to add dependencies with rebar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{deps_dir,"deps"}
{deps,[application_name,
       {application_name,"1.0.*"},
       {application_name,"1.0.*",
                         {git,"git://github.com/rebar/rebar.git",
                              {branch,"master"}}},
       {application_name,[],
                         {git,"git://github.com/rebar/rebar.git",
                              {branch,"master"}},
                         [raw]}]}
</code></pre></div></div>

<p>Use this command to automatic get dependencies:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rebar get-deps
</code></pre></div></div>

<h2 id="test-with-eunit">Test with Eunit</h2>

<p>Rebar could also compile with test. I am just using eunit for now. I add these code in <code class="language-plaintext highlighter-rouge">rebar.config</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{cover_enabled, true}.
{eunit_opts, [verbose, {report, {eunit_surefire, [{dir, "./"}]}}]}.
</code></pre></div></div>

<p>You can put test codes in subdirectory <code class="language-plaintext highlighter-rouge">test</code>. While run <code class="language-plaintext highlighter-rouge">rebar test</code>, rebar compile test code, put the object files in <code class="language-plaintext highlighter-rouge">.eunit</code>. It will also show test coverage in a web page.</p>

<h2 id="run-the-application">Run the Application</h2>

<p>Here comes the most important part. We will build and run our application. The rebar official wiki has an article about how to handle release, but it doesnâ€™t mention how to handle release with dependencies. I will introduce how I do it.</p>

<p>We already know we could use <code class="language-plaintext highlighter-rouge">rebar compile</code> to compile the codes. But it only put object files in <code class="language-plaintext highlighter-rouge">ebin/</code>, we also need to run them in the shell manually if we want:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>erl -pa ./ebin ./deps/*/ebin
</code></pre></div></div>

<p>This command will start the shell with compiled files, and you can run them in the shell.</p>

<p>But it is absolutely not we want. We want a executable file, just run it to start. Even better, run as a daemon. Even more better, attach it when we want.</p>

<p>Rebar allows us to do all test things. It is a little complex, but much simpler than the origin way with erlang.</p>

<p>First, make a new directory in the application directory, and using rebar to generate some files:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir rel
cd rel
rebar create-node nodeid=myapp
</code></pre></div></div>

<p>These command will create a subdirectory named <code class="language-plaintext highlighter-rouge">files</code> and a file named <code class="language-plaintext highlighter-rouge">reltool.config</code>. We need not to touch anything in the <code class="language-plaintext highlighter-rouge">files</code> directory. But we will modify something in <code class="language-plaintext highlighter-rouge">reltool.config</code>. Iâ€™m using erlang R16B01, and I do these things:</p>

<ol>
  <li>Add <code class="language-plaintext highlighter-rouge">{lib_dirs, ["../deps"]},</code> in the <code class="language-plaintext highlighter-rouge">sys</code> config. This will include our dependencies.</li>
  <li>Change <code class="language-plaintext highlighter-rouge">{app, myapp, [{mod_cond, app}, {incl_cond, include}]}</code> to <code class="language-plaintext highlighter-rouge">{app, myapp, [{mod_cond, app}, {incl_cond, include}, {lib_dir, ".."}]}</code>.</li>
  <li>Add <code class="language-plaintext highlighter-rouge">{sub_dirs, ["rel"]}.</code> in <code class="language-plaintext highlighter-rouge">rebar.config</code>.</li>
</ol>

<p>Now, we could generate the executable files:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rebar compile generate
</code></pre></div></div>

<p>This command will generate files in <code class="language-plaintext highlighter-rouge">rel/myapp</code>. We can run the app with erlang shell like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./rel/myapp/bin/myapp/myapp console
</code></pre></div></div>

<p>Use <code class="language-plaintext highlighter-rouge">start</code> argument will start as a daemon, and using <code class="language-plaintext highlighter-rouge">attach</code> could come back to the erlang shell. You can see the usage with <code class="language-plaintext highlighter-rouge">help</code> argument.</p>

<p>OK, enjoy your self!</p>

<h2 id="reference">Reference</h2>

<ul>
  <li>Erlang application manual: just run <code class="language-plaintext highlighter-rouge">erl -man application</code>.</li>
  <li><a href="http://www.erlang.org/doc/design_principles/users_guide.html">OTP design principles</a>.</li>
  <li><a href="https://github.com/basho/rebar/wiki">Rebar official wiki</a>.</li>
</ul>

:ET