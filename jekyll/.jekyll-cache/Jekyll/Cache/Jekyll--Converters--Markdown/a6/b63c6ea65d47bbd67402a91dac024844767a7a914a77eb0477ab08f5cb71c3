I"”<p>Some months ago, I wrote a blog named â€œ<a href="/2012-12-18-Call-Program-Like-A-Function.html">Call Program Like A Function</a>â€. In that blog, I said using pipe in shell is like calling function: <code>A | B</code> is like <code>A(B())</code>. And I also said itâ€™s difficult to write in shell like <code>A(B(), C())</code>. Read this blog again today, I realize this thought is not totally right.</p>

<p>The thought above is based on this suppose: If we see program in shell like the function in programming, then the arguments of this â€œfunctionâ€ is standard input, the result of the â€œfunctionâ€ is standard output. There could only be one standard input, so the â€œfunctionâ€ must have one argument. In this way, there is no way to call program like <code>A(B(), C())</code>. But we could discuss these two points.</p>

<h2 id="standard-input-as-arguments">Standard input as arguments</h2>

<p>But think about the program could receive arguments from shell, we need not treat standard input as its argument. In C programming, itâ€™s like:</p>

<pre><code>int main(int argc, char *argv[])
{
	return 0;
}
</code></pre>

<p><code>argc</code> is the number of arguments, and <code>argv</code> is what they are. So there is no need to see standard input as the programâ€™s arguments.</p>

<h2 id="standard-output-as-return-value">Standard output as return value</h2>

<p>Now letâ€™s think about why we treat programâ€™s standard output as functionâ€™s return value. In the example above, you could return other type as you want, such as <code>void</code>, <code>char</code> and so on. But there will be a warning while compiling and the result will be transformed to <code>int</code> at last. You can try to modify the code like this:</p>

<pre><code>char main(int argc, char *argv[])
{
	return 'a';
}
</code></pre>

<p>Then compile and see the return value:</p>

<pre><code>~/testing Â» gcc -Wall a.c
a.c:4:11: warning: return type of â€˜mainâ€™ is not â€˜intâ€™ [-Wmain]
------------------------------------------------------------
~/testing Â» ./a.out
------------------------------------------------------------
~/testing Â» echo $?
46
</code></pre>

<p>So if we want to get more information from program, we should get its output. Luckily, itâ€™s easy to do it in shell. Using <code>$()</code> you could get the output of program and using them in the shell. For example:</p>

<pre><code>echo `ls`
</code></pre>

<h2 id="and-then">And then?</h2>

<p>So if we treat arguments of program as functionâ€™s argument, standard output value as functionâ€™s return value, then <code>A(B(), C())</code> could be written as <code>A `B` `C`</code>  in shell.</p>

<p>And there is a note. In C programming, the type you could return is almost the same with what you can return in program. But when you want to get a stringâ€™s value in a function, you can use a stringâ€™s pointer as its argument and assignment to it. But you can not do it in shell.</p>

:ET